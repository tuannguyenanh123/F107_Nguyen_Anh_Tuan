1. 
    a. - Type FormattedWalletBalance has not inherited the type defined above (type WalletBalance)
       - Type Props inherits type BoxProps but this type b has not been defined
       - Unused variables: the children variable is extracted using object destructuring (const { children, ...rest } = props)
    b. - Function getPriority has arguments but has no clear type definition and with the way of writing the switch case condition as below, we can define the data type for the input argument as string type.
       - Function definition but not used
       - The key attribute passed to component WalletRow to get the index from the map is not good
    c. - Unnecessary memoization: The sortedBalances array is memoized using useMemo()
2. Explain: 
    a. - the children variable is extracted using object destructuring (const { children, ...rest } = props) but it is not used in the code block. If not needed, it can be removed to improve code clean.
    b. - Inefficient filtering: The sortedBalances array is filtered using balances.filter() to exclude certain balances. However, the filtering logic is flawed. The condition if (lhsPriority > -99) should be if (balancePriority > -99) to correctly check the priority of the balance. 
            Additionally, the condition if (balance.amount <= 0) allows balances with zero or negative amounts to pass through the filter, which may be unintended.
       - Sorting comparison: the sorting comparison is unnecessarily complex in The sortedBalances array. Instead of comparing leftPriority and rightPriority, the comparison can be simplified to return rightPriority - leftPriority.
                               =======================================================================================            
                                            (.sort((lhs: WalletBalance, rhs: WalletBalance) => {
                                                const leftPriority = getPriority(lhs.blockchain);
                                                const rightPriority = getPriority(rhs.blockchain);
                                                return rightPriority - leftPriority;
                                            }))
                                ======================================================================================
       - Unoptimized loop: The formattedBalances array is generated by mapping over sortedBalances and creating a new object for each balance. 
            However, the formatted property is computed using balance.amount.toFixed(), which converts the number to a formatted string. 
            because this operation is performed for every balance, so can be computationally expensive, especially if the array is very large. 
            It would be more efficient to format the balances only when needed, such as during rendering.
       - Key used in component WalletRow is not good:  When you do not have a stable id for the displayed items, you should not use index as a key because if the key is an index, then when we change the position of elements in the array (delete, add...), index will also change and the problem will occur again, re-rendering unnecessary parts.
    c. - Unnecessary memoization: variable prices in the memoization dependency array are not used, the memoization does not provide any optimal performance benefits
